using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Workspaces;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.MSBuild;
using System;
using System.Collections.Generic;
using System.Linq;
using System.CodeDom;


namespace LanguageServer
{
    class Goto
    {
        void main(string path_project, bool visitor, string g4_file_path, string symbol_name)
        {
            // start Roslyn workspace
            var w = MSBuildWorkspace.Create();
            var project = w.OpenProjectAsync(path_project).Result;
            
            // Get the symbol name as a string.
            //var symbol_name = symbol.Name;
            //var capitalized_symbol_name = Capitalized(symbol_name);

            // Parse all the C# files in the solution.
            Dictionary<string, SyntaxTree> trees = new Dictionary<string, SyntaxTree>();
            foreach (var item in project.Documents)
            {
                string file_name = item.Name;
                if (file_name != null)
                {
                    string suffix = Path.GetExtension(file_name);
                    if (suffix != ".cs") continue;
                    try
                    {
                        string ffn = file_name;
                        StreamReader sr = new StreamReader(ffn);
                        string code = sr.ReadToEnd();
                        SyntaxTree tree = CSharpSyntaxTree.ParseText(code);
                        trees[ffn] = tree;
                    }
                    catch (Exception)
                    {
                    }
                }
            }

            // Get the symbol name as a string.
            var capitalized_symbol_name = Capitalized(symbol_name);

            // Get name of base class for listener and visitor. These are generated by Antlr,
            // constructed from the name of the file.
            var grammar_name = Path.GetFileName(g4_file_path);
            grammar_name = Path.GetFileNameWithoutExtension(grammar_name);
            var listener_baseclass_name = visitor ? (grammar_name + "BaseVisitor") : (grammar_name + "BaseListener");
            var listener_class_name = visitor ? ("My" + grammar_name + "Visitor") : ("My" + grammar_name + "Listener");

            // Find all occurrences of visitor class.
            List<ClassDeclarationSyntax> found_class = new List<ClassDeclarationSyntax>();
            string class_file_path = null;
            try
            {
                foreach (var kvp in trees)
                {
                    var file_name = kvp.Key;
                    var tree = kvp.Value;

                    // Look for IParseTreeListener or IParseTreeVisitor classes.
                    var root = (CompilationUnitSyntax)tree.GetRoot();
                    if (root == null) continue;
                    foreach (var nm in root.Members)
                    {
                        var namespace_member = nm as NamespaceDeclarationSyntax;
                        if (namespace_member == null) continue;
                        foreach (var cm in namespace_member.Members)
                        {
                            var class_member = cm as ClassDeclarationSyntax;
                            if (class_member == null) continue;
                            var bls = class_member.BaseList;
                            if (bls == null) continue;
                            var types = bls.Types;
                            Regex reg = new Regex("[<].+[>]");
                            foreach (var type in types)
                            {
                                var s = type.ToString();
                                s = reg.Replace(s, "");
                                if (s.ToString() == listener_baseclass_name)
                                {
                                    // Found the right class.
                                    found_class.Add(class_member);
                                }
                            }
                        }
                    }
                }
            }
            catch
            {
            }

            if (found_class.Count == 0)
            {
                if (!Options.Option.GetBoolean("GenerateVisitorListener"))
                    return;

                // Look in grammar directory for any C# files.
                string name_space = null;
                string ffn = Path.GetFullPath(g4_file_path);
                ffn = Path.GetDirectoryName(ffn);
                foreach (var i in project.Documents)
                {
                    string file_name = i.Name;
                    if (file_name != null)
                    {
                        string suffix = Path.GetExtension(file_name);
                        if (suffix != ".cs") continue;
                        try
                        {
                            // Look for namespace.
                            var t = trees[file_name];
                            if (t == null) continue;
                            var root = t.GetCompilationUnitRoot();
                            foreach (var nm in root.Members)
                            {
                                var namespace_member = nm as NamespaceDeclarationSyntax;
                                if (namespace_member == null) continue;
                                name_space = namespace_member.Name.ToString();
                                break;
                            }
                        }
                        catch (Exception)
                        {
                        }
                    }
                }
                if (name_space == null) name_space = "Generated";

                // Create class.
                string clazz = visitor ? $@"
using System;
using System.Collections.Generic;
using System.Text;

namespace {name_space}
{{
    class {listener_class_name}<Result> : {listener_baseclass_name}<Result>
    {{
        //public override Result VisitA([NotNull] A3Parser.AContext context)
        //{{
        //  return VisitChildren(context);
        //}}
    }}
}}
"
                : $@"
using System;
using System.Collections.Generic;
using System.Text;

namespace {name_space}
{{
    class {listener_class_name} : {listener_baseclass_name}
    {{
        //public override void EnterA(A3Parser.AContext context)
        //{{
        //    base.EnterA(context);
        //}}
        //public override void ExitA(A3Parser.AContext context)
        //{{
        //    base.ExitA(context);
        //}}
    }}
}}
";

                class_file_path = ffn + Path.DirectorySeparatorChar + listener_class_name + ".cs";
                System.IO.File.WriteAllText(class_file_path, clazz);
                project.AddDocument(class_file_path, clazz, null, null);

                // Redo parse.
                try
                {
                    StreamReader sr = new StreamReader(class_file_path);
                    string code = sr.ReadToEnd();
                    SyntaxTree tree = CSharpSyntaxTree.ParseText(code);
                    trees[class_file_path] = tree;
                }
                catch (Exception)
                {
                }
                // Redo find class.
                try
                {
                    var tree = trees[class_file_path];
                    var save = class_file_path;
                    class_file_path = null;
                    // Look for IParseTreeListener or IParseTreeVisitor classes.
                    var root = (CompilationUnitSyntax)tree.GetRoot();
                    foreach (var nm in root.Members)
                    {
                        var namespace_member = nm as NamespaceDeclarationSyntax;
                        if (namespace_member == null) continue;
                        foreach (var cm in namespace_member.Members)
                        {
                            var class_member = cm as ClassDeclarationSyntax;
                            if (class_member == null) continue;
                            var bls = class_member.BaseList;
                            if (bls == null) continue;
                            var types = bls.Types;
                            Regex reg = new Regex("[<].+[>]");
                            foreach (var type in types)
                            {
                                var s = type.ToString();
                                s = reg.Replace(s, "");
                                if (s.ToString() == listener_baseclass_name)
                                {
                                    // Found the right class.
                                    found_class.Add(class_member);
                                    throw new Exception();
                                }
                            }
                        }
                    }
                }
                catch
                {
                }
            }

            // Look for enter or exit method for symbol.
            MethodDeclarationSyntax found_member = null;
            bool ctl = true; //CtrlKeyState.GetStateForView(grammar_view).Enabled;
            var capitalized_member_name = "";
            if (visitor) capitalized_member_name = "Visit" + capitalized_symbol_name;
            else if (ctl) capitalized_member_name = "Exit" + capitalized_symbol_name;
            else capitalized_member_name = "Enter" + capitalized_symbol_name;
            var capitalized_grammar_name = Capitalized(grammar_name);
            try
            {
                foreach (var fc in found_class)
                {
                    foreach (var me in fc.Members)
                    {
                        var method_member = me as MethodDeclarationSyntax;
                        if (method_member == null) continue;
                        if (method_member.Identifier.ValueText.ToLower() == capitalized_member_name.ToLower())
                        {
                            found_member = method_member;
                            throw new Exception();
                        }
                    }
                }
            }
            catch
            {
            }
            if (found_member == null)
            {
                if (!Options.Option.GetBoolean("GenerateVisitorListener"))
                    return;

                // Find point for edit.
                var fc = found_class.First();
                var here = fc.OpenBraceToken;
                var spn = here.FullSpan;
                var end = spn.End;

                StreamReader sr = new StreamReader(class_file_path);
                string code = sr.ReadToEnd();

                // Create class.
                string member = visitor ? $@"
public override Result {capitalized_member_name}([NotNull] {capitalized_grammar_name}Parser.{capitalized_symbol_name}Context context)
{{
    return VisitChildren(context);
}}
"
                    : $@"
public override void {capitalized_member_name}({capitalized_grammar_name}Parser.{capitalized_symbol_name}Context context)
{{
    base.{capitalized_member_name}(context);
}}
";
                code = code.Insert(end, member);

                // Redo parse.
                try
                {
                    SyntaxTree tree = CSharpSyntaxTree.ParseText(code);
                    trees[class_file_path] = tree;
                }
                catch (Exception)
                {
                }
                // Redo find class.
                try
                {
                    var tree = trees[class_file_path];
                    var save = class_file_path;
                    class_file_path = null;
                    // Look for IParseTreeListener or IParseTreeVisitor classes.
                    var root = (CompilationUnitSyntax)tree.GetRoot();
                    foreach (var nm in root.Members)
                    {
                        var namespace_member = nm as NamespaceDeclarationSyntax;
                        if (namespace_member == null) continue;
                        foreach (var cm in namespace_member.Members)
                        {
                            var class_member = cm as ClassDeclarationSyntax;
                            if (class_member == null) continue;
                            var bls = class_member.BaseList;
                            if (bls == null) continue;
                            var types = bls.Types;
                            Regex reg = new Regex("[<].+[>]");
                            foreach (var type in types)
                            {
                                var s = type.ToString();
                                s = reg.Replace(s, "");
                                if (s.ToString() == listener_baseclass_name)
                                {
                                    // Found the right class.
                                    found_class.Add(class_member);
                                    class_file_path = save;
                                    throw new Exception();
                                }
                            }
                        }
                    }
                }
                catch
                {
                }
                try
                {
                    foreach (var fcc in found_class)
                    {
                        foreach (var me in fcc.Members)
                        {
                            var method_member = me as MethodDeclarationSyntax;
                            if (method_member == null) continue;
                            if (method_member.Identifier.ValueText.ToLower() == capitalized_member_name.ToLower())
                            {
                                found_member = method_member;
                                throw new Exception();
                            }
                        }
                    }
                }
                catch
                {
                }
            }
        }

        string Capitalized(string s)
        {
            if (string.IsNullOrEmpty(s))
            {
                return string.Empty;
            }
            return char.ToUpper(s[0]) + s.Substring(1);
        }
    }
}
